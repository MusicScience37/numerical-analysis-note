% !TEX root = ../main.tex
%

\section{線形方程式の反復解法}

ここでは，変数 $\bm{x} \in \setC^n$ に関する線形方程式
$A \bm{x} = \bm{b}$
($A \in \setC^{m \times n}$, $\bm{b} \in \setC^m$)
を反復的に解くアルゴリズムについて説明する．
このようなアルゴリズムは以下のような場合に役に立つ．
\begin{itemize}
    \item 行列のサイズ $m$, $n$ が大きいが，行列 $A$ が疎行列になっている場合，
          行列分解では大きな密行列ができてしまってコンピューターのメモリが足りなくなるが，
          疎行列 $A$ を疎行列のまま扱える反復解法であれば使用できる．
          このような状況は，例えば偏微分方程式の数値計算において発生する．
    \item 行列 $A$ 自身を計算するのは困難だが，
          行列 $A$ を与えられたベクトル $\bm{x}$ にかけた $A \bm{x}$ は比較的容易に計算できる場合，
          $A \bm{x}$ さえ計算できれば使用できるタイプの反復解法を使用して
          線形方程式 $A \bm{x} = \bm{b}$ を解くことができる．
          このような状況は，
          例えば \ref{sec:ode_runge-kutta_without-jacobian} 節において扱う．
\end{itemize}

\TODO{対称行列の CG 法と PCG 法に触れておきたい．}

行列 $A$ が対称とは限らない正方行列である場合に使用できる反復解法の例として，
BiCGstab (Algorithm \ref{alg:matrix-computation__bicgstab})
\index{BiCGstab}
\footnote{実装を意識して一部記法の変更を加えている．}
が挙げられる．
ベクトル $\bm{x}$ について $A \bm{x}$ が計算できれば使用できるアルゴリズムとなっている．

\begin{algorithm}[tp]
    \caption{BiCGstab \cite{Golub2013}}
    \label{alg:matrix-computation__bicgstab}
    \begin{algorithmic}
        \Procedure{BiCGstab}{$A \in \setR^{n \times n}, \bm{b} \in \setR^n, \bm{x}_0 \in \setR^n$}
        \State $\bm{r} \gets \bm{b} - A \bm{x}_0$
        \State $\tilde{\bm{r}}_0$ を零ベクトルでない値に設定
        \Comment 残差 $\bm{r}$ にしておけば良い．
        \State $\bm{x} \gets \bm{x}_0$
        \State $\bm{p} \gets \bm{r}$
        \State $\rho \gets \tilde{\bm{r}}_0^\top \bm{r}$
        \Loop
        \State $\bm{p}' \gets A \bm{p}$
        \State $\mu \gets \frac{\tilde{\bm{r}}_0^\top \bm{r}}{\tilde{\bm{r}}_0^\top \bm{p}'}$
        \State $\bm{s} \gets \bm{r} - \mu \bm{p}'$
        \State $\bm{s}' \gets A \bm{s}$
        \State $\omega \gets \frac{\bm{s}^\top \bm{s}'}{\|\bm{s}'\|_2^2}$
        \State $\bm{x} \gets \bm{x} + \mu \bm{p} + \omega \bm{s}$
        \State $\bm{r} \gets \bm{s} - \omega \bm{s}'$
        \If{$\|\bm{r}\|_2 < tolerance$}
        \State \Return $\bm{x}$
        \EndIf
        \State $\rho_{old} \gets \rho$
        \State $\rho \gets \tilde{\bm{r}}_0^\top \bm{r}$
        \State $\tau \gets \frac{\rho \mu}{\rho_{old} \omega}$
        \State $\bm{p} \gets \bm{r} + \tau(\bm{p} - \omega \bm{p}')$
        \EndLoop
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\subsection{Algebraic Multigrid 法}

\index{Algebric Multigrid}
\index{AMG|see{Algebraic Multigrid}}

ここで，
大規模で対称な疎行列 $A \in \setR^{n \times n}$ を係数とする
線形方程式 $A \bm{x} = \bm{b}$ の解法の 1 つである
Algebraic Multigrid (AMG) 法
\cite{Ruge1987}
について説明する．

偏微分方程式の解法においては，
対称となる領域（1 次元の弦，2 次元の水面や膜，3 次元の室内など）をグリッドに分け，
各点ごとに近傍の点との位置関係などをもとにして
係数行列 $A$ が作られる．
このような場合，方程式 $A \bm{x} = \bm{b}$ は近傍の点との関係のみを示すことになるが，
細かいグリッドにおける方程式 $A \bm{x} = \bm{b}$ と
荒いグリッドにおける方程式 $A' \bm{x}' = \bm{b}'$ を用意しておくことで，
領域全体の大まかな傾向は荒いグリッドで計算し，
細かい部分は細かいグリッドで計算するといった使い分けができるようになり，
細かいグリッドにおける詳細な解の計算を高速化することができる．
そのようにして，複数の細かさの異なるグリッドを使い分けて
最終的には細かいグリッドにおける詳細な解まで求められるようにしていくというのが
基本的な Multigrid 法の考え方となっている．
そのような細かさの異なるグリッドを実際のグリッドの形状から作るのではなく，
細かいグリッドにおける係数行列の値をもとに
荒いグリッドにおける係数行列を求めるようにして実現するのが
AMG 法である．

\begin{algorithm}[tp]
    \caption{Algebraic Multigrid (AMG) 法の準備 \cite{Ruge1987,Wolters2002}}
    \label{alg:matrix-computation_amg_setup}
    \begin{algorithmic}
        \Procedure{AMGSetup}{$A \in \setR^{n \times n}$}
        \State 係数行列 $A$ のグリッドの点のインデックスの集合を $\Omega_1$ とする．
        \State $A_1 \gets A$
        \State $m \gets 1$
        \Loop
        \State $A_m$ の値をもとに $\Omega_m$ から一段荒いグリッドに使用するインデックスを選択し，
        その集合を $\Omega_{m+1}$ とする．
        \State $\Omega_{m+1}$ 上のベクトルを $\Omega_{m}$ 上のベクトルに変換する
        補間の行列 $P_{m+1}^{m}$ を生成する．
        \State $\Omega_{m}$ 上のベクトルを $\Omega_{m+1}$ 上のベクトルに変換する
        行列 $P_{m}^{m+1} = {P_{m+1}^{m}}^\top$ を用意する．
        \State $\Omega_{m+1}$ 上の係数行列 $A_{m+1} = P_{m}^{m+1} A_{m} P_{m+1}^{m}$ を算出する．
        \If{係数行列 $A_{m+1}$ が行列分解を適用できる程度に小さくなった}
        \State \Return
        \EndIf
        \State $m \gets m + 1$
        \EndLoop
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

AMG 法では，
Algorithm \ref{alg:matrix-computation_amg_setup}
のようにして係数行列 $A$ から反復的に荒いグリッドを生成していく．
反復を停止する条件として，
文献 \cite{Wolters2002} ではグリッドの点数が 1000 を下回ることが用いられている．
